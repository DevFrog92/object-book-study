# 객체지향 프로그래밍

## 영화 예매 시스템

사용자가 영화를 예매한다는 것은 특정 시간에 상영되는 영화를 관람할 수 있는 권리를 구맹하는 것이다. 
즉, 사용자는 상영을 구매하는 것이다.

할인의 경우에는 할인 조건(discount condition)과 할인 정책(discount policy)이 있다.
할인 조건에는 기간 조건과 순서 조건이 있다. 할인 정책에는 금액 할인 정책과 비율 할인 정책이 있다.

영화별로 하나의 할인 정책만 할당할 수 있다. 하지만 할인 조건은 중첩이 가능하다.

## 객체지향 프로그래밍을 향해

### 협력, 객체, 클래스

객체지향은 객체를 지향하는 것이다. 

첫쩨, 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민해야 한다. 클래스는 어떤 공통적인 상태와 행동을 공유하는 객체들을 추상화 한 것이다.
둘째, 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다. 
객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.
객체들의 모양과 윤곽이 잡히면 공통된 특선과 상태를 지닌 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해야 한다.

## 도메인의 구조를 따르는 프로그램 구조

소프트웨어는 기본적으로 사용자가 원하는 특정 문제를 해결하기 위해 만들어진다. 
공연 예매 시스템의 목적은 공연을 더 쉽고 편리하게 예매하려는 사용자의 문제를 해결하는 것이다. 
이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 **도메인**이라고 부른다.

## 클래스 구현하기

클래스를 구현할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다. 클래스의 내부와 외부를 구분해야 하는 이유는 무엇일까?
그 이유는 경계의 명확성이 객체의 자율성을 보장하기 때문이다. 그리고 프로그래머에게 구현의 자유를 제공한다.

여기서 자율성에 대해 자세히 알아보자.

### 자율적인 객체

앞에서 설명한 객체는 상태와 행동을 함께 가지는 복합적인 존재이다. 그리고 객체가 스스로 판단하고 행동하는 자율적인 존재이다. 
앞에서 설명하는 상태와 행동을 객체 내부로 함께 묶는 것을 **캡슐화** 라고 한다.
대부분의 객체지향 프로그래밍 언어들은 캡슐화에서 한 단계 더 나아가 외부에서의 접근을 통제할 수 있는 접근 제어 메커니즘(접근 수정자를 제공)도 함께 제공한다.

객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.
객체지향의 핵심은 객체 스스로 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것이다.
즉, 외부에서 객체가 어떤 상태를 가지고 어떻게 판단하고 행동하는지 알아서는 안되고, 판단과 행동에 직접 개입하면 안된다.
Chapter 01 에서 본 카페 예제에서 캐셔가 내 지갑을 열고 돈을 가져다서 결제하는 것은 나의 상태와 판단, 행동에 직접적인 개입을 한 것이다.
만약, 필요한 것이 있다면 개입이 아닌 요청을 통해서 원하는 것을 응답 받아야 한다. 이때 요청하는 것을 메지시를 전송한다고 표현하고, 메시지를 받는 쪽은 메시지를 수신했다고 표현한다.

캡슐화와 접근 제어는 객체를 두 부분으로 구분한다. 하나는 외부에서 접근할 수 있는 다른말로 요청할 수 있는 통로로 이를 퍼블릭 **인터페이스(interface)** 라고 부른다. 
다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 **구현(implementation)** 이라고 부른다. 구현은 외부에서 확인할 수 없도록 꽁꽁 싸매져 있고 이를 **구현 은닉(implementation hiding)** 이라고 한다.
이는 인터페이스와 구현의 분리 원칙으로 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.

설계가 필요한 이유는 변경을 관리하기 위해서라는 것을 기억해야 한다.

## Template Method pattern

부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴이다.


## 다형성, 상속, 인터페이스

코드의 의존성과 실행 시점의 의존성은 서로 다를 수 있다. 즉, 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다. 
이는 유연한 설계를 가능하게 하지만 트레이드오프에서는 벗어날 수 없다. 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워지지만, 반대로 재사용성과 확장 가능성이 올라가다.

상속은 객체지향에서 코드를 재사용하기 위해 가장 널리 사용되는 방법이다. 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍이라고 부른다.
상속이 가치 있는 것은 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. 코드에서 자식 클래스가 부모 클래스를 대신하는 것을 업케스팅이라고 부른다.
상속은 구현 상속와 인터페이스 상속으로 분류할 수 있는데, 구현 상속을 서브 클래싱이라고 부르고 인터페이스 상속을 서브 타이핑이라고 부른다. 
대부분은 인터페이스 상속을 위해서 상속을 사용해야 한다. 구현 상속은 변경에 취약한 코드를 작성할 위험이 있다.

인터페이스는 객체가 이행할 수 있는 메시지의 목록을 정의한다. 메시지와 메서드는 다른 개념이니 헷갈리면 안된다.
객체가 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇인가에 따라서 달라딘다. 이를 다형성이라고 부른다.

다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다. 
즉, 다형성은 컴파일 시간 의존성과 실행 시간 의존성을 다르게 만들 수 있는 객체지향의 특성을 이용해 서로 다른 메서드를 실행할 수 있게 한다.
이때 메시지와 메서다를 실행 시점에 결정하는 것을 지연 바인딩 또는 동적 바인딩이라고 부른다. 이와 반대로 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩 또는 정적 바인딩이라고 한다.

## 코드의 재사용

코드를 재사용하기 위해서는 상속 보다는 합성이 저 좋은 방법이 될 수 있다. 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말한다.

그렇다면 왜 상속보다 합성이 좋은 것일까?

상속은 두 가지 관점에서 설계에 안 좋은 영향을 미친다. 하나는 상속이 캡슐화를 위반한다는 것이고, 다른 하나는 설계를 유연하지 못하게 만든다는 것이다.
상속을 하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다.

합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이다.
