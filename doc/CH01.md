# Procedural programming vs OOP

프로그래밍을 공부하다 보면 절자적 프로그래밍과 객체지향 프로그래밍, 함수형 프로그래밍에 대해서 접하게 된다.

이때 절차적 프로그래밍과 객체지향 프로그래밍을 많이 비교하게 된다.

프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍이라고 한다. 여기서 프로세스는 데이터를 처리하는 메서드로 이해할 수 있다.

즉, 모든 처리가 하나의 클래스 안에 위치하고 나머지 클래스는 단지 데이터의 역할만 수행하게 된다.

이러한 절차적 프로그래밍은 일반적인 인간의 직관을 위배하게 된다.

우리가 카페에 갔다고 생각해 보자. 우리는 점원에게 주문을 하고 점원은 바리스타에게 커피를 주문하게 된다.

이때 손님, 점원 그리고 바리스타의 행동을 살펴보자

손님은 점원에게 주문하고 주문한 커피 값을 결제 하고 커피를 건네 받는다.

점원은 주문을 받고 주문에 대한 결제를 손님에게 요청하고 바리스타에게 커피 제조를 요청 한다.

바리스타는 커피 제조 요청이 들어오면 커피를 제조하고 손님에게 커피를 건넨다.

위의 과정은 우리가 일반적으로 생각할 수 있는 시나리오다.

하지만 절차적 프로그래밍은 하나의 프로세스에서 이러한 시나리오를 수행한다.

커피전문점에 들어가면 점원이 알아서 우리의 주문을 받고 알아서 우리의 지갑을 열어 결제를 한다. 그리고 바리스타에게 커피를 제조하도록 지시하고 완성된 커피를 가져와 우리의 손에 쥐어준다.

뭔가 이상하지 않은가?? 그렇다. 절차적 프로그래밍은 하나의 주최가 모든 행동을 컨트롤하게 되고, 각각의 역할을 가진 객체들은 수동적인 객체가 된다. 하나의 주최의 지휘 아래의 객체가 자율적일 수 없는 이유다.

하지만 남이 우리의 지갑을 마음대로 뒤지는데 가만히 있을 수 있겠는가? 현실 세계에서 위와 같은 일이 일어난다면 매우 불쾌할 것이다.

그리고 절차적 프로그래밍은 데이터의 변경을 지역적으로 고립시키지 못한다.

위의 시나리오에서 손님이 지갑이 아니라 삼성 페이로 결제를 한다면? 손님의 결제 수단의 변경으로 점원의 결제 프로세스 부분이 함께 변경되어야 한다. 이러한 전역적인 변경은 잠재적인 버그가 우리의 코드에 숨어드는 것을 발견하지 못하게 눈을 가리게 된다.

위의 문제를 해결하기 위해서는 일반적인 직관에 맞는 자율적인 객체의 설계가 필요하다. 즉 자신의 상태(데이터)는 자신이 지킬 수 있는 자율적인 객체로 말이다.

가장 간단한 방법으로 데이터를 사용하는 프로세스를 데이터를 소유하고 있는 객체의 내부로 옮기는 것이다. 이를 책임의 이동이라고 한다.

## 책임의 이동

절차적 프로그래밍과 객제지향 프로그래밍의 근본적인 차이를 만드는 것은 책임의 이동(shift of responsbility)이다.

즉, 데이터를 사용하는 프로세스와 데이터를 하나의 물리적 객체 내부에 포함시키는 것이다. 이는 하나의 객체가 수행할 수 있는 행동을 응집한 것이고 이러한 행동들을 객체지향에서는 책임이라고 부른다. 하지만 이는 지극히 구현의 관점이고 개념적인 부분이 더 있다. 이는 추후에 더 알아보자.

이를 통해서 우리는 객체지향의 핵심이 객체간의 협력을 위해, 각 객체에 역할에 맞는 적절한 책임을 할당하는 것이라는 것을 알 수 있다.

정리하자면 객체지향 프로그래밍은 캡슐화 등을 통해서, 흔히 결합도를 낮추고 응집도를 높인 자율적인 객체 설계를 해야 한다고 말한다.

하지만 설계에는 반드시 트레이드오프가 따른다. 그렇기 때문에 적장한 타협 또한 필요하다.

설계에 대한 짤막한 글로 마무리 하려고 한다.

설계는 균형의 예술이고, 적정한 트레이드오프의 결과물이다.


